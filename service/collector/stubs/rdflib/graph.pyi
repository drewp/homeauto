# Stubs for rdflib.graph (Python 3.4)
#


from typing import Any, Optional, Tuple, Sequence, Iterable
from io import StringIO as BytesIO
from rdflib import StatementType
from rdflib.term import Node, URIRef

# real Graph is a subclass of Node, but I have bugs where the context
# in a statement is the wrong one of Graph or URIRef, so I want that to be more clear.
class Graph:
    context_aware = ...  # type: Any
    formula_aware = ...  # type: Any
    def __init__(self, store='', identifier: Optional[URIRef]=None, namespace_manager=None): ...
    store = ...  # type: Any
    identifier: URIRef = ... 
    namespace_manager = ...  # type: Any
    def toPython(self): ...
    def destroy(self, configuration): ...
    def commit(self): ...
    def rollback(self): ...
    def open(self, configuration, create=False): ...
    def close(self, commit_pending_transaction=False): ...
    def add(self, xxx_todo_changeme): ...
    def addN(self, quads: Iterable[StatementType]): ...
    def remove(self, xxx_todo_changeme1): ...
    def triples(self, xxx_todo_changeme2) -> Sequence[Tuple[Node, Node, Node]]: ...
    def __getitem__(self, item): ...
    def __len__(self) -> int: ...
    def __iter__(self): ...
    def __contains__(self, triple) -> bool: ...
    def __hash__(self): ...
    def md5_term_hash(self): ...
    def __cmp__(self, other): ...
    def __eq__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def __add__(self, other): ...
    def __mul__(self, other): ...
    def __sub__(self, other): ...
    def __xor__(self, other): ...
    __or__ = ...  # type: Any
    __and__ = ...  # type: Any
    def set(self, triple): ...
    def subjects(self, predicate=None, object=None) -> Sequence[Node]: ...
    def predicates(self, subject=None, object=None) -> Sequence[Node]: ...
    def objects(self, subject=None, predicate=None) -> Sequence[Node]: ...
    def subject_predicates(self, object=None) -> Sequence[Tuple[Node, Node]]: ...
    def subject_objects(self, predicate=None) -> Sequence[Tuple[Node, Node]]: ...
    def predicate_objects(self, subject=None) -> Sequence[Tuple[Node, Node]]: ...
    def triples_choices(self, xxx_todo_changeme3, context=None): ...
    def value(self, subject=None, predicate=..., object=None, default=None, any=True) -> Optional[Node]: ...
    def label(self, subject, default='') -> Optional[Node]: ...
    def preferredLabel(self, subject, lang=None, default=None, labelProperties=...): ...
    def comment(self, subject, default=''): ...
    def items(self, list): ...
    def transitiveClosure(self, func, arg, seen=None): ...
    def transitive_objects(self, subject, property, remember=None): ...
    def transitive_subjects(self, predicate, object, remember=None): ...
    def seq(self, subject): ...
    def qname(self, uri): ...
    def compute_qname(self, uri, generate=True): ...
    def bind(self, prefix, namespace, override=True): ...
    def namespaces(self): ...
    def absolutize(self, uri, defrag=1): ...
    def serialize(self, destination=None, format='', base=None, encoding=None, **args): ...
    def parse(self, source=None, publicID=None, format=None, location=None, file=None, data=None, **args): ...
    def load(self, source, publicID=None, format=''): ...
    def query(self, query_object, processor='', result='', initNs=None, initBindings=None, use_store_provided=True, **kwargs): ...
    def update(self, update_object, processor='', initNs=..., initBindings=..., use_store_provided=True, **kwargs): ...
    def n3(self): ...
    def __reduce__(self): ...
    def isomorphic(self, other): ...
    def connected(self): ...
    def all_nodes(self): ...
    def resource(self, identifier): ...
    def skolemize(self, new_graph=None, bnode=None): ...
    def de_skolemize(self, new_graph=None, uriref=None): ...

class ConjunctiveGraph(Graph):
    context_aware = ...  # type: Any
    default_context = ...  # type: Any
    def __init__(self, store='', identifier=None): ...
    def __contains__(self, triple_or_quad): ...
    def add(self, xxx_todo_changeme4): ...
    def addN(self, quads: Iterable[StatementType]): ...
    def remove(self, xxx_todo_changeme5): ...
    def triples(self, xxx_todo_changeme6, context=None): ...
    def quads(self, pattern=None) -> Iterable[StatementType]: ...
    def triples_choices(self, xxx_todo_changeme7): ...
    def __len__(self): ...
    def contexts(self, triple=None): ...
    def get_context(self, identifier, quoted=False): ...
    def remove_context(self, context): ...
    def context_id(self, uri, context_id=None): ...
    def parse(self, source=None, publicID=None, format='', location=None, file=None, data=None, **args): ...
    def __reduce__(self): ...

class Dataset(ConjunctiveGraph):
    __doc__ = ...  # type: Any
    DEFAULT = ...  # type: Any
    graph_names = ...  # type: Any
    def __init__(self, store=''): ...
    def graph(self, identifier=None): ...
    def remove_graph(self, g): ...
    def graphs(self, empty=True): ...
    def add_quad(self, quad): ...
    def remove_quad(self, xxx_todo_changeme8): ...
    def quads(self, quad): ...

class QuotedGraph(Graph):
    def __init__(self, store, identifier): ...
    def add(self, triple): ...
    def addN(self, quads): ...
    def n3(self): ...
    def __reduce__(self): ...

class GraphValue(QuotedGraph):
    def __init__(self, store, identifier=None, graph=None): ...
    def add(self, triple): ...
    def remove(self, triple): ...
    def __reduce__(self): ...

class Seq:
    def __init__(self, graph, subject): ...
    def toPython(self): ...
    def __iter__(self): ...
    def __len__(self): ...
    def __getitem__(self, index): ...

class ModificationException(Exception):
    def __init__(self): ...

class UnSupportedAggregateOperation(Exception):
    def __init__(self): ...

class ReadOnlyGraphAggregate(ConjunctiveGraph):
    graphs = ...  # type: Any
    def __init__(self, graphs, store=''): ...
    def destroy(self, configuration): ...
    def commit(self): ...
    def rollback(self): ...
    def open(self, configuration, create=False): ...
    def close(self): ...
    def add(self, xxx_todo_changeme12): ...
    def addN(self, quads): ...
    def remove(self, xxx_todo_changeme13): ...
    def triples(self, xxx_todo_changeme14): ...
    def __contains__(self, triple_or_quad): ...
    def quads(self, xxx_todo_changeme15): ...
    def __len__(self): ...
    def __hash__(self): ...
    def __cmp__(self, other): ...
    def __iadd__(self, other): ...
    def __isub__(self, other): ...
    def triples_choices(self, xxx_todo_changeme16, context=None): ...
    def qname(self, uri): ...
    def compute_qname(self, uri, generate=True): ...
    def bind(self, prefix, namespace, override=True): ...
    def namespaces(self): ...
    def absolutize(self, uri, defrag=1): ...
    def parse(self, source, publicID=None, format='', **args): ...
    def n3(self): ...
    def __reduce__(self): ...
